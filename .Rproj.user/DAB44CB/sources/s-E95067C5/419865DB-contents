#==============================================
# make random transfers of 1 to 5 nodes between two communities
#==============================================

random_transfer <- function(graph, t_A = 1,t_B = 1){
  net_tt <- graph
  V(net_tt)$transfer <- "no"
  total = t_A + t_B
  for (k in 1:total){
    if (k <= t_A){
      letter <- "A"
    }else{
      letter <- "B"
    }
    rand <- sample(V(net_tt)[tax == letter & transfer == "no"],1)

    rand_1 <- rand
    all_rand <- c()
    deg_rand <- 1

    while (igraph::degree(net_tt,rand) <= deg_rand){
      rand <- sample(V(net_tt)[tax == letter & transfer == "no"],1)
      rand_1 <- rand
    }

    #select 1 to 5 nodes, each randomly
    number_nodes <- sample(1:5,1)

    for (i in 1:number_nodes) {
      degree1 <- ego(net_tt, order = 1, nodes = rand)
      if (length(degree1[[1]]) == 1){
        break
      }
      all_rand <- append(all_rand, V(net_tt)$name[rand])
      rand <- sample(degree1[[1]][-1],1)

      a <- 0
      while (igraph::degree(net_tt,rand) <= deg_rand & a < 4){
        rand <- sample(degree1[[1]][-1],1)
        a = a+1
      }
      if (igraph::degree(net_tt,rand) <= deg_rand){
        rand <- V(net_tt)[names(which.max(igraph::degree(net_tt,degree1[[1]][-1])))]
      }
    }
    all_rand <- unique(all_rand)
    V(net_tt)[all_rand]$transfer <- "yes"
    #find the edges between the transfers
    keep_edges <- net_tt %s% induced.subgraph(net_tt,all_rand)

    #make a new graph with adjacent nodes
    egoG <- induced.subgraph(net_tt,unlist(ego(net_tt, order=1, nodes = all_rand)))

    #subtract the edges from new graph to original,isolating the transfers
    net_tt <- net_tt %m% egoG
    net_tt <- simplify(net_tt)

    #add again the keep_edges
    net_tt <- add.edges(net_tt, get.edgelist(keep_edges))

    #make link to other community
    other_comm <- sample(V(net_tt)[tax != letter],1)
    net_tt <- add.edges(net_tt, c(V(net_tt)[rand_1], other_comm))
    node_deg0 <- V(net_tt)[which(igraph::degree(net_tt,V(net_tt))== 0)]
    for(node in node_deg0){
      letter2 <- V(net_tt)$tax[node]
      if(V(net_tt)[node]$transfer == "no"){
        net_tt <- add_edges(net_tt,c(V(net_tt)[node],sample(V(net_tt)[tax == letter2 & transfer == "no"],1)))
      }else{
        net_tt <- add_edges(net_tt,c(V(net_tt)[node],sample(V(net_tt)[tax != letter2 & transfer == "no"],1)))
      }

    }

  }
  return(net_tt)
}

# make a list of the names of the nodes of interest
nodes_of_interest <- c("a35","b11")

# select the nodes having these names
selnodes <- V(net_t)[name %in% nodes_of_interest]
# get their network neighborhood
selegoV <- ego(net_t, order=1, nodes = "a22", mode = "all", mindist = 0)

# turn the returned list of igraph.vs objects into a graph
selegoG <- induced_subgraph(net_t,unlist(selegoV))

# plot the subgraph
plot(selegoG,vertex.label=V(selegoG)$name)

all_f1score <- list()
all_recall <- list()
f1score <- rep(0, 100)
recall <- rep(0, 100)
percentages <- c()
percentages$A <- c(0,0,0,2,2,2,5,5,10)
percentages$B <- c(2,5,10,2,5,10,5,10,10)

set.seed(4864)
set.seed(666)
for(j in 1:length(percentages$A)){
  num_A = percentages$A[j]
  num_B = percentages$B[j]
  cat(num_A,num_B)
  for(i in 1:500){
    transferTest <- random_transfer(net_t1,num_A,num_B)
    truth <- V(transferTest)$transfer
    pred <- transfer2(transferTest)
    f1score[i] <- F1_Score(truth, pred, "yes")
    recall[i] <- Recall(truth, pred, "yes")
  }
  all_f1score[[j]] <- f1score
  all_recall[[j]] <- recall
}

names(all_f1score) <- c("10","20","30","40","50","60","70","80","90","100")
boxplot(all_recall, xaxt="n", range = 1, las = 2, col = rgb(1,0.2,0.1,0.7), outline = FALSE)
text(seq_along(all_recall), par("usr")[3], labels = names(all_f1score), srt = 45, adj = 1.2, xpd = TRUE, cex = 1.3)
boxplot(all_f1score, xaxt="n", range = 1, las = 2, col = rgb(0,0.6,0.1,0.7), outline = FALSE)


for(i in 1:100){
  transferTest <- random_transfer(net_t1,2,5)
  truth <- noquote(V(transferTest)$transfer)
  pred <- transfer2(transferTest)
  f1score[i] <- F1_Score(truth, pred, "yes")
  recall[i] <- Recall(truth, pred, "yes")
  print(i)
}
all_f1score[[5]] <- f1score
all_recall[[5]] <- recall

#===========================================================================================
#iterate in many folders with tree size, and calculate transfer and f1 score of the transfer
#===========================================================================================
#all_f1score <- list()
#all_recall <- list()
all_absscore <- list()
#for (i in seq(10,100,10)){

  print(i)
  file_comm <- list.files(sprintf("Trees/tree_%d",i), pattern = "*comm.txt", full.names = TRUE)
  file_edge <- list.files(sprintf("Trees/tree_%d",i), pattern = "*edges.txt", full.names = TRUE)
  #lnet <- mapply(load_network,file_edge,file_comm)
  F1_scores <- c()
  Recall_score <- c()
  Abs_score <- c()
  for( j in 1:length(file_comm)){
    #F1 score / recall
    a = load_network_pred(file_edge[j],file_comm[j],"equal")
    truth <- noquote(V(a)$transfer)
    pred <- Transfer(a)

    # F1_scores <- append(F1_scores,F1_Score(truth,pred,"yes"))
    # F1_scores[is.na(F1_scores)] <- 0
    # Recall_score <- append(Recall_score,Recall(truth,pred))

    #Absolute score
    Abs_score <- append(Abs_score,abs(length(which(truth == "yes")) - length(which(pred == "yes"))))
    }
  # all_f1score[[i/10]] <- F1_scores
  # all_recall[[i/10]] <- Recall_score
  all_absscore <- mean(Abs_score)
}
all_absscore


a <- set_color(a)
plot(a, vertex.size = 10)
truth <- noquote(V(transferTest)$transfer)
pred <- transfer2(transferTest)
F1_Score(truth, pred, "yes")

set.seed(66)
net_tt <- random_transfer(net_t,10,10)
plot(net_tt)

#=============================
# time simulation : first make different sizes graphs
# add $tax and $name and make random transfers
# time to recover the transfer using function
#=============================

for (i in c(10,100,500,1000,5000,10000)){
  connectivity <- 1/i * 5
  net_t <- erdos.renyi.game(i, connectivity, "gnp", directed = FALSE, loops = FALSE)
  V(net_t)$tax <- tax_assign(i/2)
  net_t <- set_color(name_assign(net_t, i/2))
  net_t <- random_transfer(net_t,i/2,i/2)
  print(sprintf("Network of %d nodes",i))
  print(system.time(Transfer(net_t)))
}


a = load_network_pred("Trees/tree_100/tree3_edges.txt","Trees/tree_100/tree3_comm.txt","equal")
truth <- noquote(V(a)$transfer)
pred <- Transfer(a)
Abs_score <- append(Abs_score,abs(length(which(truth == "yes")) - length(which(pred == "yes"))))
Abs_score
