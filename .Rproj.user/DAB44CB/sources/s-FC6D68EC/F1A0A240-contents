#==========================================================================================================================================================
#= Function to calculate dist_paths with doParallel
#=
#= Input: graph, an undirected igraph with color levels (V(graph)$tax)
#=        nom_col1, character string that indicates the color 1 attribute
#=		  nom_col2, character string that indicates the color 2 attribute
#=
#= Output: list of distances values in the following order : dpr,dl,dlpr,dnpr
#=
#= All shortest paths are calculated between vertices of same colors
#= Requires SDDE, igraph, foreach and doParallel packages
#= Multi-core backend has to be set
#=
#= Ex:
#= Works only for two colors graph
#==========================================================================================================================================================

#modifie en juillet 2018 - henry
shortest_paths_graph <- function(graph,v1,v2,v.mix,col1,col2,opti,mean_w,max_w){
  all_paths <- c()
  x.col1<-foreach(a=v1[-(length(v1))], i=icount(), .combine="+", .inorder=FALSE, .packages='igraph') %:%
    foreach(b=v1[(i+1):length(v1)], .combine="+", .inorder=FALSE, .packages='igraph') %dopar% { #for all color 1 vertices
      owarn <- getOption("warn")
      options(warn = -1) # Silence warnings for not reachable vertices
      # Get all shortest paths from the v.col1[i] vertex to v.col1[j] vertex
      # The $res attribute of paths contains all shortest paths (vertices sequence) calculated in a list.
      if (opti == "all"){
        paths = get.all.shortest.paths(graph, a, b, mode= "all")$res
      } else if(opti == "single"){
        paths = get.shortest.paths(graph, a, b, mode= "all")$vpath
      }
      options(warn = owarn)
      all_paths <- append(all_paths,paths)
    }
  return(all_paths)
}

dist_par<-function(igraph, nom_col1, nom_col2,distance,opti="single",maxcores=1,share_w){
  tic("total")
  tic("graph init")
  cl <- makeCluster(multicore(maxcores))
  registerDoParallel(cl=cl)

  #modifie juillet 2018 par henry
  #find the nodes with mixed communities
  col1_mix <- paste(append(nom_col1,"-"),collapse = "")
  col1_mix2 <- paste(append("-",nom_col1),collapse = "")

  #find the ones that contain the communities in this iteration
  v.mix <- grep(col1_mix,V(igraph)$tax)
  v.mix <- append(v.mix,grep(col1_mix2,V(igraph)$tax))

  #same for second community
  col2_mix <- paste(append(nom_col2,"-"),collapse = "")
  col2_mix2 <- paste(append("-",nom_col2),collapse = "")
  v.mix2 <- grep(col1_mix,V(igraph)$tax)
  v.mix2 <- append(v.mix2,grep(col1_mix2,V(igraph)$tax))

  graph = subgroup_graph(igraph,c(nom_col1,nom_col2,V(igraph)$tax[v.mix],V(igraph)$tax[v.mix2]))
  m_weight = mean(E(graph)$weight)
  max_weight = sum(E(graph)$weight)
  if (components(graph)$no > 1){
    graph = reconnect(graph)
  }
  #print(V(graph))

  ## Get vertex by colors
  col1 <- nom_col1
  col2 <- nom_col2
  mask.col1 <-which(V(graph)$tax == col1)
  mask.col2 <-which(V(graph)$tax == col2)
  v.mix <- grep(col_mix,V(graph)$tax)
  v.col1 <-V(graph)[mask.col1] #all vertices of color 1 and mix
  v.col1 <- append(v.col1,V(graph)[v.mix])
  v.col2 <-V(graph)[mask.col2] #all vertices of color 2
  #print(v.col1)
  #print(v.col2)

  #cat(v.col1,v.col2)
  # All vertices of color1 and 2 (Those vertices may or may not be in the graph, it depends on the network type)
  # (This does not affect the distance calculation for graph with no vertices of mix colors)
  # if(col1 > col2){
  # 	mix <-paste0(col2, col1, sep="")
  # }else{
  # 	mix <-paste0(col1, col2, sep="")
  # }
  # mask.mix <-which(V(graph)$tax == mix)
  # v.mix <-V(graph)[mask.mix]

  ## Shortest path search for all pair of same color vertex
  toc()
  tic("shortest paths")

  # Color 1
  if(length(v.col1) >=2){
    x.col1 = shortest_paths_graph(graph,v.col1,v.col2,v.mix,col1,col2,opti,m_weight,max_weight)
  }

  v.col1 <-V(graph)[mask.col1]
  v.col2 <- append(v.col2,V(graph)[v.mix2])
  # Color 2
  if(length(v.col2) >=2){
    x.col2 = shortest_paths_graph(graph,v.col2,v.col1,v.mix2,col2,col1,opti,m_weight,max_weight)
  }
  toc()
  tic("finishing")
  toc()
  stopCluster(cl)
  toc()
  return(c(x.col1,x.col2))

}

